---
title: Go
date: 2023-03-05
icon: go
category:
- 后端技术
tag:
- 后端
- Go
---



## 为什么选择Go

- 云时代的语言
- 写法很像JS和TS（自己认为）

```go
func main(){
    
}
```

Go的设计哲学

**不要徘徊在第一次就想把事情做到完美**

## 接口与结构体

Go 语言的接口常用于代表某种能力或某类特征。首先，我们要弄清楚的是，接口变量的动态值、动态类型和静态类型都代表了什么。这些都是正确使用接口变量的基础。当我们给接口变量赋值时，接口变量会持有被赋予值的副本，而不是它本身。

接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是`nil`，这也是它的零值。

更重要的是，接口变量的值并不等同于这个可被称为动态值的副本。它会包含两个指针，一个指针指向动态值，一个指针指向类型信息。

基于此，即使我们把一个值为`nil`的某个实现类型的变量赋给了接口变量，后者的值也不可能是真正的`nil`。虽然这时它的动态值会为`nil`，但它的动态类型确是存在的。

怎样才能让一个接口变量的值真正为`nil`呢？要么只声明它但不做初始化，要么直接把字面量`nil`赋给它。

### 动态类型和静态类型

```go
type Pet interface {
	SetName(name string)
	Name() string
	Category() string
}
```

我声明了一个接口类型`Pet`，它包含了 3 个方法定义，方法名称分别为`SetName`、`Name`和`Category`。这 3 个方法共同组成了接口类型`Pet`的方法集合。

只要一个数据类型的方法集合中有这 3 个方法，那么它就一定是`Pet`接口的实现类型。这是一种无侵入式的接口实现方式，即鸭子类型。

我声明的类型`Dog`附带了 3 个方法。其中有 2 个值方法，分别是`Name`和`Category`，另外还有一个指针方法`SetName`。

这就意味着，`Dog`类型本身的方法集合中只包含了 2 个方法，也就是所有的值方法。而它的指针类型`*Dog`方法集合却包含了 3 个方法，

也就是说，它拥有`Dog`类型附带的所有值方法和指针方法。又由于这 3 个方法恰恰分别是`Pet`接口中某个方法的实现，所以`*Dog`类型就成为了`Pet`接口的实现类型。

```go
dog := Dog{"little pig"}
var pet Pet = &dog
```

正因为如此，我可以声明并初始化一个`Dog`类型的变量`dog`，然后把它的指针值赋给类型为`Pet`的变量`pet`。

这里有几个名词需要你先记住。对于一个接口类型的变量来说，例如上面的变量`pet`，我们赋给它的值可以被叫做它的实际值（也称**动态值**），而该值的类型可以被叫做这个变量的实际类型（也称**动态类型**）。

比如，我们把取址表达式`&dog`的结果值赋给了变量`pet`，这时这个结果值就是变量`pet`的动态值，而此结果值的类型`*Dog`就是该变量的动态类型。

动态类型这个叫法是相对于**静态类型**而言的。对于变量`pet`来讲，它的**静态类型**就是`Pet`，并且永远是`Pet`，但是它的动态类型却会随着我们赋给它的动态值而变化。

比如，只有我把一个`*Dog`类型的值赋给变量`pet`之后，该变量的动态类型才会是`*Dog`。如果还有一个`Pet`接口的实现类型`*Fish`，并且我又把一个此类型的值赋给了`pet`，那么它的动态类型就会变为`*Fish`。

还有，在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。

当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。

### 接口组合

接口类型间的嵌入也被称为接口的组合。我在前面讲过结构体类型的嵌入字段，这其实就是在说结构体类型间的嵌入。

接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。

```go
type Animal interface {
	ScientificName() string
	Category() string
}
 
type Pet interface {
	Animal
	Name() string
}
```

接口类型`Pet`包含了两个成员，一个是代表了另一个接口类型的`Animal`，一个是方法`Name`的定义。它们都被包含在`Pet`的类型声明的花括号中，并且都各自独占一行。此时，`Animal`接口包含的所有方法也就成为了`Pet`接口的方法。

Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。

这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。

### 结构体



### 指针

- **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。

- 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。

- 若拿到某值的指针可能会破坏程序的一致性，那么就是**不安全的**，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。

- **对切片字面量的索引结果值是可寻址的**

## 并发

*goroutines* 是 Go 的基本并发单元，它让我们可以同时检查多个网站。

*anonymous functions（匿名函数）*，我们用它来启动每个检查网站的并发进程。

*channels*，用来组织和控制不同进程之间的交流，使我们能够避免 *race condition（竞争条件）* 的问题。

*the race detector（竞争探测器）* 帮助我们调试并发代码的问题。



## 语法糖

### …

1. 函数的参数声明，如：`func VariableParamFunc(nums ...int)`，在函数的方法体内，nums 作为一个切片`[]int`来使用。
2. 传参时列表打散，如：`params = []int{1,2,3}`，调用某个有三个参数的方法 `func ThreeParamFunc(a, b, c int)`时可以`ThreeParamFunc(params...)`
3. 在数组声明时，如果元素指定，那么可以不必显式声明数组长度，可以根据元素个数推断，如：`arr := [...]int{1,2,3} // len(arr) == 3`
4. 在 go 命令行中，被当做包列表的通配符。如：
   `$ go test ./...` 这条命令会执行当前目录及子目录下的所有包测试文件。
