---
title: 动态规划
date: 2023-02-03
icon: line
category:
- 数据结构与算法
tag:
- 动态规划
- dp
---



## 时间复杂度分析

时间复杂度=状态的数量*每个状态需要花费的时间

## 解题框架

1. 明确dp数组以及数组下标的含义

2. 推导递推公式

3. dp数组初始化

4. 确定遍历顺序

5. 举例推导dp数组

**找问题的最好方式就是把dp数组打印出来**

## 线性DP

### LC70 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

- 输入： 2
- 输出： 2
- 解释： 有两种方法可以爬到楼顶。
  - 1 阶 + 1 阶
  - 2 阶

示例 2：

- 输入： 3

- 输出： 3

- 解释： 有三种方法可以爬到楼顶。
  - 1 阶 + 1 阶 + 1 阶
  
  - 1 阶 + 2 阶
  
  - 2 阶 + 1 阶
  



1.dp[i]： 爬到第i层楼梯，有dp[i]种方法

2.首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

3.dp[1]=1,dp[2]=2,dp[0]无意义。

4.从前向后遍历

5.举例推导dp数组

|   i   |  1   |  2   |  3   |  4   |  5   |
| :---: | :--: | :--: | :--: | :--: | :--: |
| dp[i] |  1   |  2   |  3   |  5   |  8   |

完整代码：


```javascript
var climbStairs = function(n) {
    // dp[i] 为第 i 阶楼梯有多少种方法爬到楼顶
    // dp[i] = dp[i - 1] + dp[i - 2]
    let dp = [1 , 2]
    for(let i = 2; i < n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    return dp[n - 1]
};
```

```typescript
function climbStairs(n: number): number {
    /**
        dp[i]: i阶楼梯的方法种数
        dp[1]: 1;
        dp[2]: 2;
        ...
        dp[i]: dp[i - 1] + dp[i - 2];
     */
    const dp: number[] = [];
    dp[1] = 1;
    dp[2] = 2;
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
};
```

### LC198 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

- 示例 1：
- 输入：[1,2,3,1]
- 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。

- 示例 2：
- 输入：[2,7,9,3,1]
- 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。  偷窃到的最高金额 = 2 + 9 + 1 = 12 。

提示：

- 0 <= nums.length <= 100

- 0 <= nums[i] <= 400



1.确定dp数组（dp table）以及下标的含义

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

2.如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房）

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])。

3.dp数组初始化

从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]

从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1])。

4.确定遍历顺序

dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！

5.举例推导dp数组

以输入[2,7,9,3,1]为例。

|   i   |  0   |  1   |  2   |  3   |  4   |
| :---: | :--: | :--: | :--: | :--: | :--: |
| dp[i] |  2   |  7   |  11  |  11  |  12  |

完整代码：

```javascript
var rob = function(nums) {
    const len = nums.length;
    if(len == 0)
        return 0;
    const dp = new Array(len + 1);
    dp[0] = 0;
    dp[1] = nums[0];
    for(let i = 2; i <= len; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
    }
    return dp[len];
};
```

## 二维DP

### LC121 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。



1.确定dp数组（dp table）以及下标的含义

dp[i] [0] 表示第i天持有股票所得最多现金,dp[i] [1] 表示第i天**不**持有股票所得最多现金

2.确定递推公式

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i-1] [0]
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]

那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i-1] [0], -prices[i]);

如果第i天不持有股票即dp[i] [0]， 也可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i-1] [1]
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i-1] [0]

同样dp[i] [0]取最大的，dp[i][1] = max(dp[i-1] [1], prices[i] + dp[i-1] [0]);

3.dp数组初始化

dp[0] [0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0] [0]-= prices[0];

dp[0] [1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0] [1] = 0

4.确定遍历顺序

从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。

5.举例推导dp数组

输入：[7,1,5,3,6]

|     i     |  0   |  1   |  2   |  3   |  4   |
| :-------: | :--: | :--: | :--: | :--: | :--: |
| dp[i] [0] |  -7  |  -1  |  -1  |  -1  |  -1  |
| dp[i] [1] |  0   |  0   |  4   |  4   |  5   |

完整代码：

```javascript
const maxProfit = prices => {
   let len=prices.length;
   const dp=new Array(len).fill([0,0])
   dp[0]=[-prices[i],0]
   for(let i=1;i<len;i++){
       dp[i]=[
           Math.max(dp[i-1][0],-prices[i]),
           Math.max(dp[i-1][1],dp[i-1][0]+prices[i])
       ]
   }
   return dp[len-1][1]
};
```

> 本文参考资料：https://www.programmercarl.com
